# robot_pi_fusion_final.py
#
# Raspberry Pi obstacle avoidance with active sensor fusion:
# - Vision (camera) builds an obstacle mask in a ROI using floor-reference LAB segmentation
# - Ultrasonic distance (via Arduino Nano) provides Z in cm
# - Calibration F_PX converts pixels -> centimeters at distance Z
# - Left/right decision uses estimated free corridor width in cm (bottom band of ROI)
# - Turn and backup durations are proportional to how tight/close the situation is
#
# Nano protocol expected:
# - From Pi to Nano: F, B, L, R, S and ? (distance request)
# - From Nano to Pi: D:<cm> (e.g., D:49.0) or D:-1

import time
import signal
import cv2
import serial
import numpy as np

# ============================================================
# CONFIG: Serial + Camera
# ============================================================
SERIAL_PORT = "/dev/ttyUSB0"   # change to /dev/ttyACM0 if needed
BAUD = 115200

CAM_INDEX = 0
W, H = 1280, 720

# If your camera feed is mirrored, set this True
FLIP_HORIZONTAL = False

# ============================================================
# CALIBRATION RESULT
# ============================================================
F_PX = 715.0   # your calibrated focal length in pixels

# ============================================================
# ROI: analyze only the floor/path ahead (tune if needed)
# ============================================================
ROI_X1 = int(W * 0.22)
ROI_X2 = int(W * 0.78)
ROI_Y1 = int(H * 0.58)
ROI_Y2 = int(H * 0.95)

# ============================================================
# BEHAVIOR / SAFETY
# ============================================================
SOFT_STOP_CM = 50.0            # start avoidance
CLEAR_CM = 45.0                # after turning, require distance > this
FORWARD_BURST_S = 0.06         # small forward steps
TURN_ATTEMPTS = 3              # repeated (turn + check) attempts

NEEDED_CLOSE_READINGS = 2      # consecutive close readings before avoid
close_count = 0

# ============================================================
# PROPORTIONAL TURNING / BACKUP
# ============================================================
TURN_MIN_S = 0.25
TURN_MAX_S = 1.20

BACKUP_MIN_S = 0.25
BACKUP_MAX_S = 0.60

# ============================================================
# ROBOT GEOMETRY
# ============================================================
ROBOT_WIDTH_CM = 16.0          # measure your chassis width
SAFETY_MARGIN_CM = 4.0
REQUIRED_FREE_CM = ROBOT_WIDTH_CM + SAFETY_MARGIN_CM

# direction tie-breaking
DIR_DEADBAND_CM = 6.0          # if |freeL-freeR| <= this, keep last direction
last_direction = 'L'

# ============================================================
# VISION: floor segmentation parameters
# ============================================================
FLOOR_PATCH_W_FRAC = 0.25
FLOOR_PATCH_H_FRAC = 0.18

K_STD = 3.5
MIN_THRESH = 35
MAX_THRESH = 120

USE_EDGE_FALLBACK = True

# corridor measurement uses a bottom band of ROI (closest part matters most)
BAND_Y1_FRAC = 0.55

# For "blocked column" detection:
# floor-mask is dense -> higher threshold works
# edges-mask is sparse -> use lower threshold
COL_BLOCK_FRAC_FLOOR = 0.18
COL_BLOCK_FRAC_EDGES = 0.06

# Print-only mode (useful over SSH)
HEADLESS = True

# ============================================================
# SETUP: serial + camera
# ============================================================
ser = serial.Serial(SERIAL_PORT, BAUD, timeout=0.35)
time.sleep(2.0)  # Nano often resets when serial opens
ser.reset_input_buffer()

cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, W)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, H)

running = True
def handle_sigint(sig, frame):
    global running
    running = False
signal.signal(signal.SIGINT, handle_sigint)

# ============================================================
# SERIAL HELPERS
# ============================================================
def send_cmd(c: str) -> None:
    ser.write((c + "\n").encode())

_last_dist = None
_last_dist_t = 0.0

def get_distance_cm(rate_hz: float = 10.0):
    global _last_dist, _last_dist_t
    now = time.time()
    if now - _last_dist_t < 1.0 / rate_hz:
        return _last_dist
    _last_dist_t = now

    ser.reset_input_buffer()
    ser.write(b'?\n')
    line = ser.readline().decode(errors='ignore').strip()

    if line.startswith("D:"):
        try:
            v = float(line[2:])
            _last_dist = None if v < 0 else v
        except:
            _last_dist = None
    else:
        _last_dist = None

    return _last_dist

# ============================================================
# VISION: obstacle mask (ROI) using floor reference in LAB
# ============================================================
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))

def compute_obstacle_mask(frame):
    """
    Returns: roi_bgr, mask(0/255), mode_string
    mask = obstacle-like pixels
    """
    roi = frame[ROI_Y1:ROI_Y2, ROI_X1:ROI_X2]
    rh, rw = roi.shape[:2]

    lab = cv2.cvtColor(roi, cv2.COLOR_BGR2LAB).astype(np.int16)

    pw = int(rw * FLOOR_PATCH_W_FRAC)
    ph = int(rh * FLOOR_PATCH_H_FRAC)
    px1 = (rw - pw) // 2
    px2 = px1 + pw
    py2 = rh
    py1 = max(0, rh - ph)

    floor_patch = lab[py1:py2, px1:px2]
    floor_mean = floor_patch.reshape(-1, 3).mean(axis=0)

    diff = np.abs(lab - floor_mean).sum(axis=2).astype(np.int16)

    floor_diff = diff[py1:py2, px1:px2].astype(np.float32)
    th = float(floor_diff.mean() + K_STD * floor_diff.std())
    th = max(MIN_THRESH, min(MAX_THRESH, th))

    mask = (diff > th).astype(np.uint8) * 255

    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=2)

    occ = mask.mean() / 255.0

    if USE_EDGE_FALLBACK and (occ < 0.01 or occ > 0.95):
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)
        edges = cv2.Canny(gray, 60, 140)
        edges = cv2.dilate(edges, kernel, iterations=1)
        return roi, edges, f"edges(th={th:.0f})"

    return roi, mask, f"floor(th={th:.0f} occ={occ:.2f})"

# ============================================================
# SENSOR FUSION: pixels -> cm using Z and F_PX
# ============================================================
def clamp(x, a, b):
    return a if x < a else b if x > b else x

def cm_per_pixel(z_cm: float) -> float:
    return z_cm / float(F_PX)

def free_corridor_cm(mask: np.ndarray, z_cm: float, mode: str):
    """
    More stable than "longest run":
    - analyze only the bottom band of ROI
    - count how many columns are "free"
    - convert free columns to cm using cm_per_pixel
    """
    rh, rw = mask.shape[:2]
    mid = rw // 2

    band_y1 = int(rh * BAND_Y1_FRAC)
    band = mask[band_y1:rh, :]

    col_occ = (band.mean(axis=0) / 255.0)

    col_block_frac = COL_BLOCK_FRAC_EDGES if mode.startswith("edges") else COL_BLOCK_FRAC_FLOOR
    blocked = col_occ > col_block_frac

    free_left_cols = int((~blocked[:mid]).sum())
    free_right_cols = int((~blocked[mid:]).sum())

    cpp = cm_per_pixel(z_cm)
    return free_left_cols * cpp, free_right_cols * cpp

def estimate_main_object_width_cm(mask: np.ndarray, z_cm: float):
    """
    Optional: estimate width of largest obstacle blob in cm.
    """
    binmask = (mask > 0).astype(np.uint8)
    n, _, stats, _ = cv2.connectedComponentsWithStats(binmask, connectivity=8)
    if n <= 1:
        return None
    best_i = 1 + np.argmax(stats[1:, cv2.CC_STAT_AREA])
    w_px = stats[best_i, cv2.CC_STAT_WIDTH]
    return w_px * cm_per_pixel(z_cm)

def choose_direction_and_times(mask: np.ndarray, z_cm: float, mode: str):
    """
    Returns: direction, freeL_cm, freeR_cm, turn_s, backup_s
    Decision uses corridor widths in cm with deadband + last_direction.
    """
    global last_direction

    freeL, freeR = free_corridor_cm(mask, z_cm, mode)

    if abs(freeL - freeR) <= DIR_DEADBAND_CM:
        direction = last_direction
    else:
        direction = 'L' if freeL > freeR else 'R'

    last_direction = direction

    best = max(freeL, freeR)
    other = min(freeL, freeR)

    shortage = clamp((REQUIRED_FREE_CM - best) / max(1e-6, REQUIRED_FREE_CM), 0.0, 1.0)
    imbalance = clamp((best - other) / max(1e-6, best + other), 0.0, 1.0)
    proximity = clamp((SOFT_STOP_CM - z_cm) / max(1e-6, SOFT_STOP_CM), 0.0, 1.0)

    strength = clamp(0.60 * shortage + 0.25 * imbalance + 0.15 * proximity, 0.0, 1.0)

    turn_s = TURN_MIN_S + strength * (TURN_MAX_S - TURN_MIN_S)
    backup_s = BACKUP_MIN_S + strength * (BACKUP_MAX_S - BACKUP_MIN_S)

    return direction, freeL, freeR, turn_s, backup_s

# ============================================================
# AVOIDANCE ROUTINE
# ============================================================
def avoid(direction: str, turn_s: float, backup_s: float) -> bool:
    send_cmd('S'); time.sleep(0.05)

    send_cmd('B'); time.sleep(backup_s)
    send_cmd('S'); time.sleep(0.05)

    for _ in range(TURN_ATTEMPTS):
        send_cmd(direction); time.sleep(turn_s)
        send_cmd('S'); time.sleep(0.05)

        d2 = get_distance_cm(rate_hz=20)
        if d2 is not None and d2 > CLEAR_CM:
            return True

        send_cmd('B'); time.sleep(0.20)
        send_cmd('S'); time.sleep(0.05)

    return False

# ============================================================
# MAIN LOOP
# ============================================================
try:
    send_cmd('S')

    while running:
        ok, frame = cap.read()
        if not ok:
            send_cmd('S')
            time.sleep(0.1)
            continue

        if FLIP_HORIZONTAL:
            frame = cv2.flip(frame, 1)

        z = get_distance_cm(rate_hz=10)

        roi, mask, mode = compute_obstacle_mask(frame)

        if z is None:
            close_count = 0
            send_cmd('S')
            if HEADLESS:
                print("dist=None action=STOP")
            time.sleep(0.05)
            continue

        close_count = close_count + 1 if z <= SOFT_STOP_CM else 0

        direction, freeL, freeR, turn_s, backup_s = choose_direction_and_times(mask, z, mode)
        obj_w = estimate_main_object_width_cm(mask, z)

        if close_count >= NEEDED_CLOSE_READINGS:
            if HEADLESS:
                msg = (
                    f"dist={z:.1f} {mode} freeL={freeL:.1f}cm freeR={freeR:.1f}cm "
                    f"dir={direction} turn={turn_s:.2f}s backup={backup_s:.2f}s action=AVOID"
                )
                if obj_w is not None:
                    msg += f" objW~{obj_w:.1f}cm"
                print(msg)

            ok1 = avoid(direction, turn_s, backup_s)
            if not ok1:
                other = 'L' if direction == 'R' else 'R'
                if HEADLESS:
                    print(f"not clear -> try other={other}")
                avoid(other, min(TURN_MAX_S, turn_s * 1.15), min(BACKUP_MAX_S, backup_s * 1.10))

            close_count = 0

        else:
            if HEADLESS:
                msg = (
                    f"dist={z:.1f} {mode} freeL={freeL:.1f}cm freeR={freeR:.1f}cm "
                    f"dir={direction} action=FWD"
                )
                if obj_w is not None:
                    msg += f" objW~{obj_w:.1f}cm"
                print(msg)

            send_cmd('F')
            time.sleep(FORWARD_BURST_S)

finally:
    try: send_cmd('S')
    except: pass
    try: cap.release()
    except: pass
    try: cv2.destroyAllWindows()
    except: pass
    try: ser.close()
    except: pass
    print("Stopped cleanly.")
